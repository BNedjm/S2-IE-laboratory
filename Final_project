#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <iomanip>
#include <cmath>

#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>

class Player : public sf::Sprite {
public:
    Player(const int& ref_speed, const std::string& path) : ref_speed_(ref_speed)
    {
        if (!texture_.loadFromFile(path)) {
            std::cerr << "Could not load texture" << std::endl;
        } else {
            texture_.setRepeated(true);
            setTexture(texture_);
            setScale(.5,.5);
            setTextureRect(sf::IntRect(0, 0, 20/.5, 160/.5));
            setOrigin(getGlobalBounds().width, getGlobalBounds().height/.5);
            setPosition(300, 810);
        }
    }

    void setSpeed(const int& ref_speed) {
        ref_speed_ = ref_speed;
    }

    void moveInDirection(const sf::Time &elapsed)
     {
        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right)){ // moving the player
            if(getRotation() <= 80 || abs(getRotation()-360) <= 90)
            rotate(abs(ref_speed_)*elapsed.asSeconds());
        } else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left)){
            if(getRotation() >= 280 || getRotation() <= 90)
            rotate(-abs(ref_speed_)*elapsed.asSeconds());
        }
     }

private:
    sf::Texture texture_;
    int ref_speed_ = 0;
};

class Objects : public sf::Sprite {
public:

private:

};

class Target : public sf::Sprite {
public:
    Target(const int x_speed) : x_speed_(x_speed)
    {
    }

    void setSpeed(const int& x_speed) { // set x speed
        x_speed_ = x_speed;
    }

    void animate(const sf::Time &elapsed){ // move elements
        bouncce();
        move(x_speed_*elapsed.asSeconds(),0);
    }

    void setBounds(const float& l_bound, const float& r_bound){ // set bounds
        l_bound_  = l_bound;
        r_bound_  = r_bound;
    }

private:
    int x_speed_ = 0;
    float l_bound_ = 0;
    float r_bound_ = 0;

    void bouncce(){ // bounds to speed function
        sf::FloatRect rectangle_bounds = getGlobalBounds();

        if(rectangle_bounds.left <= l_bound_ ){
           x_speed_ = abs(x_speed_);
        }

        if(rectangle_bounds.left + rectangle_bounds.width >= r_bound_){
            x_speed_ = abs(x_speed_) * -1;
        }
    }
};

int main()
{
    sf::RenderWindow window(sf::VideoMode(600, 800), "Project X"); // create the window

    sf::Clock clock;

    sf::Texture tex_target, tex_player;

    int ref_speed = 25;

    std::vector <Target> targets; // targets vector def
    if (!tex_target.loadFromFile("grass.png")) {
        std::cerr << "Could not load texture" << std::endl;
        return 1;
    } else {
        tex_target.setRepeated(true);
        for (int i = 1; i < 6; i++){
            Target target(i*ref_speed); // target elements def
            target.setTexture(tex_target);
            target.setBounds(0, window.getSize().x);
            target.setScale(.5,.5);
            target.setPosition(10,-20+i*30);
            target.setTextureRect(sf::IntRect(0, 0, 20*i/.5, 20/.5));
            targets.push_back(target);
        }
    }
    targets.at(0).setSpeed(40); // set speed for the smallest target

    Player player(50, "C:\\Users\\boukh\\OneDrive\\Bureau\\wall.png");
    /*sf::Sprite player; // player def
    if (!tex_player.loadFromFile("wall.png")) {
        std::cerr << "Could not load texture" << std::endl;
        return 1;
    } else {
        tex_player.setRepeated(true);
        player.setTexture(tex_player);
        player.setScale(.5,.5);
        player.setTextureRect(sf::IntRect(0, 0, 20/.5, 160/.5));
        player.setOrigin(10/.5, 160/.5);
        player.setPosition(300, 810);
    }*/

    while (window.isOpen()) {

        sf::Time elapsed = clock.restart();
        sf::Event event;

        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }
        window.clear(sf::Color::Black);

        player.moveInDirection(elapsed);

        for(auto &t : targets){ // moving the targets
            t.animate(elapsed);
            window.draw(t);
        }

        std::cout << 800-player.getGlobalBounds().top << std::endl;
        window.draw(player);

        window.display();
    }

    return 0;
}
