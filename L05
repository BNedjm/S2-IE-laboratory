#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <iomanip>

#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>

class Labyrinth  : public sf::Sprite {
public:
    Labyrinth (/*const sf::Vector2f &position, const sf::Vector2f &scale*/)
    {
        //setPosition(position);
        //setScale(scale);
    }

    void setSpeed(const int& x_speed, const int& y_speed/*, const int & ro_speed*/) {
        x_speed_ = x_speed;
        y_speed_ = y_speed;
        //ro_speed_ = ro_speed;
    }

    void setBounds(const float& l_bound, const float& r_bound,const float& u_bound,const float& d_bound){
        l_bound_  = l_bound  ;
        r_bound_  = r_bound  ;
        u_bound_  = u_bound  ;
        d_bound_  = d_bound  ;
    }

    void moveInDirection(const sf::Time &elapsed, const sf::Keyboard::Key &key, int &ind){
        float dt = elapsed.asSeconds();
        bool up = false, down = false, left = false, right = false;
        int x = 0, y = 0;
        //--------------------------------------------------------------------------
        //sf::Keyboard::isKeyPressed(key) is added here to stop the object if key is not pressed
        if(key == sf::Keyboard::Right && sf::Keyboard::isKeyPressed(key)){
            if(getGlobalBounds().left+getGlobalBounds().width <= r_bound_){
                right = true;
            }
        }
        else if (key == sf::Keyboard::Left && sf::Keyboard::isKeyPressed(key)){
            if(getGlobalBounds().left >= l_bound_){
                left = true;
            }
        }
        if (key == sf::Keyboard::Up && sf::Keyboard::isKeyPressed(key)){
            if(getGlobalBounds().top >= u_bound_){
                up = true;
            }
        }
        else if (key == sf::Keyboard::Down && sf::Keyboard::isKeyPressed(key)){
            if(getGlobalBounds().top+getGlobalBounds().height <= d_bound_){
                down = true;
            }
        }
        //--------------------------------------------------------------------------
        // I added this section for the sake of diagonal motion
        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && sf::Keyboard::isKeyPressed(sf::Keyboard::Right)){
            if(getGlobalBounds().left+getGlobalBounds().width <= r_bound_ && getGlobalBounds().top >= u_bound_){
                right = true;
                up = true;
            }
        } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && sf::Keyboard::isKeyPressed(sf::Keyboard::Left)){
            if(getGlobalBounds().left >= l_bound_ && getGlobalBounds().top >= u_bound_){
                left = true;
                up = true;
            }
        }
        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && sf::Keyboard::isKeyPressed(sf::Keyboard::Right)){
            if(getGlobalBounds().left+getGlobalBounds().width <= r_bound_ && getGlobalBounds().top+getGlobalBounds().height <= d_bound_){
                right = true;
                down = true;
            }
        } else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down) && sf::Keyboard::isKeyPressed(sf::Keyboard::Left)){
            if(getGlobalBounds().left >= l_bound_ && getGlobalBounds().top+getGlobalBounds().height <= d_bound_){
                left = true;
                down = true;
            }
        }
        //--------------------------------------------------------------------------
        switch (ind) {
        case 1:
            up = false;
            break;
        case 2:
            down = false;
            break;
        case 3:
            left = false;
            break;
        case 4:
            right = false;
            break;
        default:
            break;
        }
        //--------------------------------------------------------------------------
        if (left)
            x-=x_speed_;
        if (right)
            x+=x_speed_;
        if (up)
            y-=y_speed_;
        if (down)
            y+=y_speed_;
        move(x*dt,y*dt);
    }

    void collusion (Labyrinth &wall){
        //ind_ = 5; //NAN
        if(getGlobalBounds().top <= wall.getGlobalBounds().top+wall.getGlobalBounds().height
                && getGlobalBounds().top > wall.getGlobalBounds().top
                && getGlobalBounds().left < wall.getGlobalBounds().left+wall.getGlobalBounds().width
                && getGlobalBounds().left+getGlobalBounds().width > wall.getGlobalBounds().left){
            ind_ = 1; //top
        }else if(getGlobalBounds().top+getGlobalBounds().height >= wall.getGlobalBounds().top
                && getGlobalBounds().top < wall.getGlobalBounds().top
                && getGlobalBounds().left < wall.getGlobalBounds().left+wall.getGlobalBounds().width
                && getGlobalBounds().left+getGlobalBounds().width > wall.getGlobalBounds().left){
            ind_ = 2; //down
        }else if(getGlobalBounds().left <= wall.getGlobalBounds().left+wall.getGlobalBounds().width
                && getGlobalBounds().left > wall.getGlobalBounds().left
                && getGlobalBounds().top < wall.getGlobalBounds().top+wall.getGlobalBounds().height
                && getGlobalBounds().top+getGlobalBounds().height > wall.getGlobalBounds().top){
            ind_ = 3; //left
        }else if(getGlobalBounds().left+getGlobalBounds().width >= wall.getGlobalBounds().left
                && getGlobalBounds().left < wall.getGlobalBounds().left
                && getGlobalBounds().top < wall.getGlobalBounds().top+wall.getGlobalBounds().height
                && getGlobalBounds().top+getGlobalBounds().height > wall.getGlobalBounds().top){
            ind_ = 4; //right
        }
    }

    int get_ind_(){
        return ind_;
    }

private:
    int ind_ = 0;
    int x_speed_ = 0 ;
    int y_speed_ = 0 ;
    //int ro_speed_ = 0 ;
    float l_bound_ = 0;
    float r_bound_ = 0;
    float u_bound_ = 0;
    float d_bound_ = 0;
    //bool selected_ = false;
};

int main()
{
    // create the window
    sf::RenderWindow window(sf::VideoMode(800, 800), "Labyrinth");

    // create textures
    sf::Texture texture_grass, texture_wall, texture_guy;
    sf::Vector2f pos_ = {0,0}, sc_ = {.5,.5};

    //------------------------------------------------------------------

    Labyrinth grass;
    if (!texture_grass.loadFromFile("grass.png")) {
        std::cerr << "Could not load texture" << std::endl;
        return 1;
    }
    texture_grass.setRepeated(true);
    grass.setTexture(texture_grass);
    grass.setScale(.5,.5);
    grass.setTextureRect(sf::IntRect(0, 0, window.getSize().x/sc_.x, window.getSize().y/sc_.y));

    //------------------------------------------------------------------

    Labyrinth wall;
    std::vector<Labyrinth> walls;

    if (!texture_wall.loadFromFile("wall.png")) {
        std::cerr << "Could not load texture" << std::endl;
        return 1;
    }
    else{
        texture_wall.setRepeated(true);
        // cube walls
        wall.setTexture(texture_wall);
        wall.setScale(.5,.5);
        wall.setTextureRect(sf::IntRect(0, 0, window.getSize().x/sc_.x, 10/sc_.y));
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, window.getSize().x/sc_.x, 10/sc_.y));
        wall.setPosition(0, window.getSize().y-10);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 10/sc_.x, ((window.getSize().y-100)/sc_.y)));
        wall.setPosition(0, 10);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 10/sc_.x, ((window.getSize().y-20)/sc_.y)));
        wall.setPosition(window.getSize().x-10, 10);
        walls.push_back(wall);
        // puzzle walls
        // 1 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (100/sc_.y)));
        wall.setPosition(90, 10);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (220/sc_.y)));
        wall.setPosition(90, 490);
        walls.push_back(wall);
        // 2 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (110/sc_.y)));
        wall.setPosition(190, 290);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (300/sc_.y)));
        wall.setPosition(190, 490);
        walls.push_back(wall);
        // 3 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (120/sc_.y)));
        wall.setPosition(290, 90);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (120/sc_.y)));
        wall.setPosition(290, 390);
        walls.push_back(wall);
        // 4 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (100/sc_.y)));
        wall.setPosition(390, 10);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (220/sc_.y)));
        wall.setPosition(390, 190);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (120/sc_.y)));
        wall.setPosition(390, 490);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (100/sc_.y)));
        wall.setPosition(390, 690);
        walls.push_back(wall);
        // 5 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (220/sc_.y)));
        wall.setPosition(490, 290);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (120/sc_.y)));
        wall.setPosition(490, 590);
        walls.push_back(wall);
        // 6 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (100/sc_.y)));
        wall.setPosition(590, 10);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (120/sc_.y)));
        wall.setPosition(590, 390);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (100/sc_.y)));
        wall.setPosition(590, 690);
        walls.push_back(wall);
        // 7 y
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (220/sc_.y)));
        wall.setPosition(690, 90);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 20/sc_.x, (320/sc_.y)));
        wall.setPosition(690, 390);
        walls.push_back(wall);
        // 1 x
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(190, 90);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 220/sc_.x, (20/sc_.y)));
        wall.setPosition(490, 90);
        walls.push_back(wall);
        // 2 x
        wall.setTextureRect(sf::IntRect(0, 0, 520/sc_.x, (20/sc_.y)));
        wall.setPosition(90, 190);
        walls.push_back(wall);
        // 3 x
        wall.setTextureRect(sf::IntRect(0, 0, 300/sc_.x, (20/sc_.y)));
        wall.setPosition(10, 290);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 220/sc_.x, (20/sc_.y)));
        wall.setPosition(490, 290);
        walls.push_back(wall);
        // 4 x
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(90, 390);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(290, 390);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 200/sc_.x, (20/sc_.y)));
        wall.setPosition(590, 390);
        walls.push_back(wall);
        // 5 x
        wall.setTextureRect(sf::IntRect(0, 0, 100/sc_.x, (20/sc_.y)));
        wall.setPosition(10, 490);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(190, 490);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(390, 490);
        walls.push_back(wall);
        // 6 x
        wall.setTextureRect(sf::IntRect(0, 0, 220/sc_.x, (20/sc_.y)));
        wall.setPosition(490, 590);
        walls.push_back(wall);
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(290, 590);
        walls.push_back(wall);
        // 7 x
        wall.setTextureRect(sf::IntRect(0, 0, 120/sc_.x, (20/sc_.y)));
        wall.setPosition(290, 690);
        walls.push_back(wall);
    }

    //------------------------------------------------------------------

    Labyrinth guy;
    if (!texture_guy.loadFromFile("guy.png")) {
        std::cerr << "Could not load texture" << std::endl;
        return 1;
    }
    guy.setTexture(texture_guy);
    guy.setScale(.5,.5);
    guy.setPosition(20,20.0);
    guy.setBounds(0, window.getSize().x, 0, window.getSize().y);
    guy.setSpeed(100, 100);

    //------------------------------------------------------------------

    // clock
    sf::Clock clock;

    // run the program as long as the window is open
    while (window.isOpen()) {

        sf::Time elapsed = clock.restart();
        int ind_ = 0;

        // check all the window's events that were triggered since the last iteration of the loop
        sf::Event event;
        while (window.pollEvent(event)) {
            // "close requested" event: we close the window
            if (event.type == sf::Event::Closed)
                window.close();
        }




        // clear the window with black color
        window.clear(sf::Color::Black);

        // draw everything here...
        window.draw(grass);
        for (auto &w : walls){
            guy.collusion(w);
            ind_ = guy.get_ind_();
            window.draw(w);
        }
        std::cout << ind_ << "\t" <<guy.getGlobalBounds().height << std::endl;
        guy.moveInDirection(elapsed, event.key.code, ind_); // move stuff
        window.draw(guy);

        // end the current frame
        window.display();
    }
    return 0;
}
